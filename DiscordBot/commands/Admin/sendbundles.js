const Users = require('../../../model/user.js');const Profiles = require('../../../model/profiles.js');const fs = require('fs');const path = require('path');const destr = require('destr');const config = require('../../../Config/config.json');const uuid = require("uuid");const axios = require('axios');const log = require("../../../structs/log.js");const { MessageEmbed } = require('discord.js');let cosmeticsCache = null;let cacheTimestamp = null;const CACHE_DURATION = 60 * 60 * 1000;async function fetchCosmeticsFromAPI() {    try {        const response = await axios.get('https://fortnite-api.com/v2/cosmetics/br');        return response.data?.data || [];    } catch (error) {        console.error('Error fetching cosmetics:', error);        return [];    }}function filterCosmeticsByType(cosmetics, type) {    return cosmetics.filter(cosmetic => {        const cosmeticType = cosmetic.type?.value?.toLowerCase();        return cosmeticType === type;    });}function getRandomCosmetic(cosmetics) {    if (cosmetics.length === 0) return null;    const randomIndex = Math.floor(Math.random() * cosmetics.length);    return cosmetics[randomIndex];}async function getCosmeticFromAllAthena(cosmeticId) {    try {        const file = fs.readFileSync(path.join(__dirname, "../../../Config/DefaultProfiles/allathena.json"));        const jsonFile = destr(file.toString());        const items = jsonFile.items;        for (const key of Object.keys(items)) {            const [type, id] = key.split(":");            if (id === cosmeticId) {                return { key, cosmetic: items[key] };            }        }        return null;    } catch (error) {        console.error('Error reading allathena.json:', error);        return null;    }}async function findRandomCosmeticOfType(cosmetics, type, profile, maxAttempts = 50) {    const filtered = filterCosmeticsByType(cosmetics, type);    let attempts = 0;    while (attempts < maxAttempts) {        const selected = getRandomCosmetic(filtered);        if (!selected) break;        const cosmeticData = await getCosmeticFromAllAthena(selected.id);        if (cosmeticData) {            if (!profile.profiles.athena.items[cosmeticData.key]) {                return { apiData: selected, cosmeticData };            }        }        attempts++;    }    return null;}module.exports = {    commandInfo: {        name: "sendbundles",        description: "Send a random bundle (Character, Pickaxe, BackBling, Emote) to a user.",        options: [            {                name: "user",                description: "The user you want to send the bundle to",                required: true,                type: 6            }        ]    },    execute: async (interaction) => {        await interaction.deferReply({ ephemeral: true });        if (!config.moderators.includes(interaction.user.id)) {            return interaction.editReply({ content: "You do not have moderator permissions.", ephemeral: true });        }        const selectedUser = interaction.options.getUser('user');        const selectedUserId = selectedUser.id;        const user = await Users.findOne({ discordId: selectedUserId });        if (!user) {            return interaction.editReply({ content: "That user does not own an account", ephemeral: true });        }        const profile = await Profiles.findOne({ accountId: user.accountId });        if (!profile) {            return interaction.editReply({ content: "That user does not own an account", ephemeral: true });        }        try {            let allCosmetics = [];            const cacheNow = Date.now();            if (cosmeticsCache && cacheTimestamp && (cacheNow - cacheTimestamp) < CACHE_DURATION) {                allCosmetics = cosmeticsCache;            } else {                await interaction.editReply({ content: "Fetching cosmetics from API...", ephemeral: true });                allCosmetics = await fetchCosmeticsFromAPI();                cosmeticsCache = allCosmetics;                cacheTimestamp = cacheNow;            }            if (allCosmetics.length === 0) {                return interaction.editReply({                     content: "Could not fetch cosmetics from API. Please try again later.",                     ephemeral: true                 });            }            const bundleItems = {                character: null,                pickaxe: null,                backbling: null,                emote: null            };            await interaction.editReply({ content: "Selecting random cosmetics for bundle...", ephemeral: true });            bundleItems.character = await findRandomCosmeticOfType(allCosmetics, 'outfit', profile);            bundleItems.pickaxe = await findRandomCosmeticOfType(allCosmetics, 'pickaxe', profile);            bundleItems.backbling = await findRandomCosmeticOfType(allCosmetics, 'backpack', profile);            bundleItems.emote = await findRandomCosmeticOfType(allCosmetics, 'emote', profile);            const missingItems = [];            if (!bundleItems.character) missingItems.push("Character");            if (!bundleItems.pickaxe) missingItems.push("Pickaxe");            if (!bundleItems.backbling) missingItems.push("BackBling");            if (!bundleItems.emote) missingItems.push("Emote");            if (missingItems.length > 0) {                return interaction.editReply({                     content: `Could not find available cosmetics for: ${missingItems.join(", ")}. The user may already have all available items of these types.`,                     ephemeral: true                 });            }            const lootList = [];            const common_core = profile.profiles["common_core"];            const athena = profile.profiles["athena"];            const ApplyProfileChanges = [];            const charData = bundleItems.character.cosmeticData;            athena.items[charData.key] = charData.cosmetic;            lootList.push({                "itemType": charData.cosmetic.templateId,                "itemGuid": charData.cosmetic.templateId,                "quantity": 1            });            ApplyProfileChanges.push({                "changeType": "itemAdded",                "itemId": charData.key,                "templateId": charData.cosmetic.templateId            });            const pickData = bundleItems.pickaxe.cosmeticData;            athena.items[pickData.key] = pickData.cosmetic;            lootList.push({                "itemType": pickData.cosmetic.templateId,                "itemGuid": pickData.cosmetic.templateId,                "quantity": 1            });            ApplyProfileChanges.push({                "changeType": "itemAdded",                "itemId": pickData.key,                "templateId": pickData.cosmetic.templateId            });            const bbData = bundleItems.backbling.cosmeticData;            athena.items[bbData.key] = bbData.cosmetic;            lootList.push({                "itemType": bbData.cosmetic.templateId,                "itemGuid": bbData.cosmetic.templateId,                "quantity": 1            });            ApplyProfileChanges.push({                "changeType": "itemAdded",                "itemId": bbData.key,                "templateId": bbData.cosmetic.templateId            });            const emoteData = bundleItems.emote.cosmeticData;            athena.items[emoteData.key] = emoteData.cosmetic;            lootList.push({                "itemType": emoteData.cosmetic.templateId,                "itemGuid": emoteData.cosmetic.templateId,                "quantity": 1            });            ApplyProfileChanges.push({                "changeType": "itemAdded",                "itemId": emoteData.key,                "templateId": emoteData.cosmetic.templateId            });            const purchaseId = uuid.v4();            common_core.items[purchaseId] = {                "templateId": `GiftBox:GB_MakeGood`,                "attributes": {                    "fromAccountId": `[${interaction.user.username}]`,                    "lootList": lootList,                    "params": {                        "userMessage": `Random Bundle: ${bundleItems.character.apiData.name}, ${bundleItems.pickaxe.apiData.name}, ${bundleItems.backbling.apiData.name}, ${bundleItems.emote.apiData.name}`                    },                    "giftedOn": new Date().toISOString()                },                "quantity": 1            };            ApplyProfileChanges.push({                "changeType": "itemAdded",                "itemId": purchaseId,                "templateId": "GiftBox:GB_MakeGood"            });            common_core.rvn++;            common_core.commandRevision++;            common_core.updated = new Date().toISOString();            athena.rvn++;            athena.commandRevision++;            athena.updated = new Date().toISOString();            await Profiles.updateOne(                { accountId: user.accountId },                {                     $set: {                         'profiles.common_core': common_core,                         'profiles.athena': athena                     }                 }            );            const embed = new MessageEmbed()                .setTitle("üéÅ Random Bundle Sent!")                .setDescription(`Successfully sent a random bundle to **${selectedUser.username}**!\n\n**Bundle Contents:**\n‚Ä¢ **Character:** ${bundleItems.character.apiData.name}\n‚Ä¢ **Pickaxe:** ${bundleItems.pickaxe.apiData.name}\n‚Ä¢ **BackBling:** ${bundleItems.backbling.apiData.name}\n‚Ä¢ **Emote:** ${bundleItems.emote.apiData.name}`)                .setColor("GREEN")                .setFooter({                    text: "Vortyx",                    iconURL: "https://i.imgur.com/VKPcwAJ.png"                })                .setTimestamp();            if (bundleItems.character.apiData.images?.icon) {                embed.setThumbnail(bundleItems.character.apiData.images.icon);            }            await interaction.editReply({ embeds: [embed], ephemeral: true });        } catch (err) {            log.error(err);            await interaction.editReply({ content: "An unexpected error occurred", ephemeral: true });        }    }};