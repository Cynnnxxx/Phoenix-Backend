const { MessageEmbed } = require("discord.js");const User = require("../../../model/user.js");const Profile = require("../../../model/profiles.js");const Trade = require("../../../model/trade.js");const functions = require("../../../structs/functions.js");const uuid = require("uuid");const axios = require("axios");async function getItemInfo(templateId) {    try {        const itemId = templateId.split(":")[1] || templateId;        const response = await axios.get(`https://fortnite-api.com/v2/cosmetics/br/search?id=${encodeURIComponent(itemId)}`, {            timeout: 5000        });        return response.data?.data || null;    } catch (error) {        return null;    }}function formatItemName(templateId, itemInfo) {    if (itemInfo && itemInfo.name) {        return itemInfo.name;    }    const parts = templateId.split(":");    if (parts.length > 1) {        return parts[1].replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());    }    return templateId;}module.exports = {    commandInfo: {        name: "tradecosmetics",        description: "Trade cosmetics with other players",        options: [            {                name: "create",                description: "Create a new trade offer",                type: 1,                options: [                    {                        name: "user",                        description: "The user you want to trade with",                        type: 6,                        required: true                    },                    {                        name: "your_item",                        description: "The item key you want to trade (use /yourlocker to see your items)",                        type: 3,                        required: true                    },                    {                        name: "their_item",                        description: "The item key you want from them (use /lookup to see their items)",                        type: 3,                        required: true                    }                ]            },            {                name: "accept",                description: "Accept a pending trade",                type: 1,                options: [                    {                        name: "trade_id",                        description: "The trade ID to accept",                        type: 3,                        required: true                    }                ]            },            {                name: "cancel",                description: "Cancel a pending trade",                type: 1,                options: [                    {                        name: "trade_id",                        description: "The trade ID to cancel",                        type: 3,                        required: true                    }                ]            },            {                name: "list",                description: "List your pending trades",                type: 1            }        ]    },    execute: async (interaction) => {        await interaction.deferReply({ ephemeral: true });        const subcommand = interaction.options.getSubcommand();        const user = await User.findOne({ discordId: interaction.user.id });        if (!user) {            return interaction.editReply({ content: "You do not have a registered account! Use `/create` to create one.", ephemeral: true });        }        try {            switch (subcommand) {                case "create":                    await handleCreateTrade(interaction, user);                    break;                case "accept":                    await handleAcceptTrade(interaction, user);                    break;                case "cancel":                    await handleCancelTrade(interaction, user);                    break;                case "list":                    await handleListTrades(interaction, user);                    break;            }        } catch (error) {            console.error("Trade command error:", error);            interaction.editReply({ content: "An error occurred while processing your trade. Please try again later.", ephemeral: true });        }    }};async function handleCreateTrade(interaction, initiatorUser) {    const targetUser = interaction.options.getUser("user");    const yourItemKey = interaction.options.get("your_item").value;    const theirItemKey = interaction.options.get("their_item").value;    if (targetUser.id === interaction.user.id) {        return interaction.editReply({ content: "You cannot trade with yourself!", ephemeral: true });    }    const receiverUser = await User.findOne({ discordId: targetUser.id });    if (!receiverUser) {        return interaction.editReply({ content: "The target user does not have a registered account!", ephemeral: true });    }    const initiatorProfile = await Profile.findOne({ accountId: initiatorUser.accountId });    const receiverProfile = await Profile.findOne({ accountId: receiverUser.accountId });    if (!initiatorProfile || !receiverProfile) {        return interaction.editReply({ content: "Could not find profiles for one or both users.", ephemeral: true });    }    const initiatorAthena = initiatorProfile.profiles?.athena?.items || {};    const receiverAthena = receiverProfile.profiles?.athena?.items || {};    if (!initiatorAthena[yourItemKey]) {        return interaction.editReply({ content: `You don't own the item with key: ${yourItemKey}. Use \`/yourlocker\` to see your items.`, ephemeral: true });    }    if (!receiverAthena[theirItemKey]) {        return interaction.editReply({ content: `The target user doesn't own the item with key: ${theirItemKey}.`, ephemeral: true });    }    const yourItem = initiatorAthena[yourItemKey];    const theirItem = receiverAthena[theirItemKey];    if (yourItem.templateId?.startsWith("Currency:") || yourItem.templateId?.startsWith("GiftBox:")) {        return interaction.editReply({ content: "You cannot trade currency or gift boxes!", ephemeral: true });    }    if (theirItem.templateId?.startsWith("Currency:") || theirItem.templateId?.startsWith("GiftBox:")) {        return interaction.editReply({ content: "The target user's item cannot be traded (currency or gift box)!", ephemeral: true });    }    const existingTrade = await Trade.findOne({        $or: [            { initiatorAccountId: initiatorUser.accountId, receiverAccountId: receiverUser.accountId, status: "pending" },            { initiatorAccountId: receiverUser.accountId, receiverAccountId: initiatorUser.accountId, status: "pending" }        ]    });    if (existingTrade) {        return interaction.editReply({ content: `You already have a pending trade with this user (Trade ID: ${existingTrade.tradeId}). Please complete or cancel it first.`, ephemeral: true });    }    const tradeId = uuid.v4().replace(/-/g, "").substring(0, 8).toUpperCase();    const trade = await Trade.create({        tradeId: tradeId,        initiatorAccountId: initiatorUser.accountId,        initiatorDiscordId: initiatorUser.discordId,        initiatorUsername: initiatorUser.username,        receiverAccountId: receiverUser.accountId,        receiverDiscordId: receiverUser.discordId,        receiverUsername: receiverUser.username,        initiatorItems: [{            itemKey: yourItemKey,            templateId: yourItem.templateId,            itemData: yourItem        }],        receiverItems: [{            itemKey: theirItemKey,            templateId: theirItem.templateId,            itemData: theirItem        }],        status: "pending"    });    const yourItemInfo = await getItemInfo(yourItem.templateId);    const theirItemInfo = await getItemInfo(theirItem.templateId);    const embed = new MessageEmbed()        .setColor("GREEN")        .setTitle("âœ… Trade Created")        .setDescription(`Trade ID: **${tradeId}**`)        .addFields(            {                name: "You're Trading",                value: `**${formatItemName(yourItem.templateId, yourItemInfo)}**\n\`${yourItemKey}\``,                inline: true            },            {                name: "You're Receiving",                value: `**${formatItemName(theirItem.templateId, theirItemInfo)}**\n\`${theirItemKey}\``,                inline: true            },            {                name: "Trade Partner",                value: `<@${targetUser.id}> (${receiverUser.username})`,                inline: false            }        )        .setFooter({            text: "The other player can accept this trade using /tradecosmetics accept",            iconURL: "https://i.imgur.com/VKPcwAJ.png"        })        .setTimestamp();    if (yourItemInfo?.images?.icon) {        embed.setThumbnail(yourItemInfo.images.icon);    }    interaction.editReply({ embeds: [embed], ephemeral: true });    try {        const targetMember = await interaction.guild.members.fetch(targetUser.id);        if (targetMember) {            const notifyEmbed = new MessageEmbed()                .setColor("BLUE")                .setTitle("ðŸ”” New Trade Offer")                .setDescription(`**${initiatorUser.username}** wants to trade with you!`)                .addFields(                    {                        name: "They're Offering",                        value: `**${formatItemName(yourItem.templateId, yourItemInfo)}**`,                        inline: true                    },                    {                        name: "They Want",                        value: `**${formatItemName(theirItem.templateId, theirItemInfo)}**`,                        inline: true                    },                    {                        name: "Trade ID",                        value: `\`${tradeId}\``,                        inline: false                    }                )                .setFooter({                    text: "Use /tradecosmetics accept to accept this trade",                    iconURL: "https://i.imgur.com/VKPcwAJ.png"                })                .setTimestamp();            await targetMember.send({ embeds: [notifyEmbed] }).catch(() => {            });        }    } catch (error) {    }}async function handleAcceptTrade(interaction, user) {    const tradeId = interaction.options.get("trade_id").value.toUpperCase();    const trade = await Trade.findOne({ tradeId: tradeId, status: "pending" });    if (!trade) {        return interaction.editReply({ content: `Trade with ID \`${tradeId}\` not found or already completed/cancelled.`, ephemeral: true });    }    if (trade.receiverAccountId !== user.accountId) {        return interaction.editReply({ content: "You are not the receiver of this trade! Only the trade receiver can accept it.", ephemeral: true });    }    if (new Date() > trade.expiresAt) {        await Trade.updateOne({ tradeId: tradeId }, { $set: { status: "expired" } });        return interaction.editReply({ content: "This trade has expired. Please create a new trade.", ephemeral: true });    }    const initiatorProfile = await Profile.findOne({ accountId: trade.initiatorAccountId });    const receiverProfile = await Profile.findOne({ accountId: trade.receiverAccountId });    if (!initiatorProfile || !receiverProfile) {        return interaction.editReply({ content: "Could not find profiles for one or both users.", ephemeral: true });    }    const initiatorAthena = initiatorProfile.profiles.athena;    const receiverAthena = receiverProfile.profiles.athena;    const initiatorCommonCore = initiatorProfile.profiles.common_core;    const receiverCommonCore = receiverProfile.profiles.common_core;    for (const item of trade.initiatorItems) {        if (!initiatorAthena.items[item.itemKey]) {            return interaction.editReply({ content: `The initiator no longer owns the item: ${item.itemKey}. Trade cancelled.`, ephemeral: true });        }    }    for (const item of trade.receiverItems) {        if (!receiverAthena.items[item.itemKey]) {            return interaction.editReply({ content: `You no longer own the item: ${item.itemKey}. Trade cancelled.`, ephemeral: true });        }    }    const initiatorApplyChanges = [];    const receiverApplyChanges = [];    for (const item of trade.initiatorItems) {        delete initiatorAthena.items[item.itemKey];        initiatorApplyChanges.push({            changeType: "itemRemoved",            itemId: item.itemKey        });    }    for (const item of trade.receiverItems) {        const newItemKey = functions.MakeID();        initiatorAthena.items[newItemKey] = JSON.parse(JSON.stringify(item.itemData));        initiatorApplyChanges.push({            changeType: "itemAdded",            itemId: newItemKey,            templateId: item.templateId        });    }    for (const item of trade.receiverItems) {        delete receiverAthena.items[item.itemKey];        receiverApplyChanges.push({            changeType: "itemRemoved",            itemId: item.itemKey        });    }    for (const item of trade.initiatorItems) {        const newItemKey = functions.MakeID();        receiverAthena.items[newItemKey] = JSON.parse(JSON.stringify(item.itemData));        receiverApplyChanges.push({            changeType: "itemAdded",            itemId: newItemKey,            templateId: item.templateId        });    }    initiatorAthena.rvn++;    initiatorAthena.commandRevision++;    receiverAthena.rvn++;    receiverAthena.commandRevision++;    initiatorCommonCore.rvn++;    initiatorCommonCore.commandRevision++;    receiverCommonCore.rvn++;    receiverCommonCore.commandRevision++;    await Profile.updateOne(        { accountId: trade.initiatorAccountId },        { $set: { profiles: initiatorProfile.profiles } }    );    await Profile.updateOne(        { accountId: trade.receiverAccountId },        { $set: { profiles: receiverProfile.profiles } }    );    await Trade.updateOne({ tradeId: tradeId }, { $set: { status: "completed" } });    const initiatorItemInfo = await getItemInfo(trade.initiatorItems[0].templateId);    const receiverItemInfo = await getItemInfo(trade.receiverItems[0].templateId);    const embed = new MessageEmbed()        .setColor("GREEN")        .setTitle("âœ… Trade Completed!")        .setDescription(`Trade ID: **${tradeId}**`)        .addFields(            {                name: "You Received",                value: `**${formatItemName(trade.initiatorItems[0].templateId, initiatorItemInfo)}**`,                inline: true            },            {                name: "You Traded",                value: `**${formatItemName(trade.receiverItems[0].templateId, receiverItemInfo)}**`,                inline: true            },            {                name: "Trade Partner",                value: `${trade.initiatorUsername}`,                inline: false            }        )        .setFooter({            text: "Pulse",            iconURL: "https://i.imgur.com/VKPcwAJ.png"        })        .setTimestamp();    if (initiatorItemInfo?.images?.icon) {        embed.setThumbnail(initiatorItemInfo.images.icon);    }    interaction.editReply({ embeds: [embed], ephemeral: true });    try {        const initiatorUser = await User.findOne({ accountId: trade.initiatorAccountId });        if (initiatorUser) {            const initiatorMember = await interaction.guild.members.fetch(initiatorUser.discordId).catch(() => null);            if (initiatorMember) {                const notifyEmbed = new MessageEmbed()                    .setColor("GREEN")                    .setTitle("âœ… Your Trade Was Accepted!")                    .setDescription(`Trade ID: **${tradeId}**`)                    .addFields(                        {                            name: "You Received",                            value: `**${formatItemName(trade.receiverItems[0].templateId, receiverItemInfo)}**`,                            inline: true                        },                        {                            name: "You Traded",                            value: `**${formatItemName(trade.initiatorItems[0].templateId, initiatorItemInfo)}**`,                            inline: true                        }                    )                    .setFooter({                        text: "Pulse",                        iconURL: "https://i.imgur.com/VKPcwAJ.png"                    })                    .setTimestamp();                await initiatorMember.send({ embeds: [notifyEmbed] }).catch(() => {});            }        }    } catch (error) {    }}async function handleCancelTrade(interaction, user) {    const tradeId = interaction.options.get("trade_id").value.toUpperCase();    const trade = await Trade.findOne({ tradeId: tradeId, status: "pending" });    if (!trade) {        return interaction.editReply({ content: `Trade with ID \`${tradeId}\` not found or already completed/cancelled.`, ephemeral: true });    }    if (trade.initiatorAccountId !== user.accountId && trade.receiverAccountId !== user.accountId) {        return interaction.editReply({ content: "You are not part of this trade!", ephemeral: true });    }    await Trade.updateOne({ tradeId: tradeId }, { $set: { status: "cancelled" } });    const embed = new MessageEmbed()        .setColor("ORANGE")        .setTitle("âŒ Trade Cancelled")        .setDescription(`Trade ID: **${tradeId}** has been cancelled.`)        .setFooter({            text: "Pulse",            iconURL: "https://i.imgur.com/VKPcwAJ.png"        })        .setTimestamp();    interaction.editReply({ embeds: [embed], ephemeral: true });}async function handleListTrades(interaction, user) {    const pendingTrades = await Trade.find({        $or: [            { initiatorAccountId: user.accountId, status: "pending" },            { receiverAccountId: user.accountId, status: "pending" }        ]    }).sort({ created: -1 }).limit(10);    if (pendingTrades.length === 0) {        return interaction.editReply({ content: "You have no pending trades.", ephemeral: true });    }    const embeds = [];    for (const trade of pendingTrades) {        const isInitiator = trade.initiatorAccountId === user.accountId;        const otherUser = isInitiator ? trade.receiverUsername : trade.initiatorUsername;        const otherDiscordId = isInitiator ? trade.receiverDiscordId : trade.initiatorDiscordId;        const yourItems = isInitiator ? trade.initiatorItems : trade.receiverItems;        const theirItems = isInitiator ? trade.receiverItems : trade.initiatorItems;        const embed = new MessageEmbed()            .setColor(isInitiator ? "BLUE" : "YELLOW")            .setTitle(`Trade ${trade.tradeId}`)            .setDescription(`Status: **${trade.status.toUpperCase()}**\n${isInitiator ? "You created this trade" : "You received this trade"}`)            .addFields(                {                    name: "You're Trading",                    value: yourItems.map(item => `**${formatItemName(item.templateId, null)}**\n\`${item.itemKey}\``).join("\n\n") || "None",                    inline: true                },                {                    name: "You're Receiving",                    value: theirItems.map(item => `**${formatItemName(item.templateId, null)}**\n\`${item.itemKey}\``).join("\n\n") || "None",                    inline: true                },                {                    name: "Trade Partner",                    value: `<@${otherDiscordId}> (${otherUser})`,                    inline: false                }            )            .setFooter({                text: isInitiator ? "Waiting for them to accept" : "Use /tradecosmetics accept to accept",                iconURL: "https://i.imgur.com/VKPcwAJ.png"            })            .setTimestamp(trade.created);        embeds.push(embed);    }    interaction.editReply({ embeds: embeds.slice(0, 10), ephemeral: true });}