const Users = require('../../../model/user.js');const Profiles = require('../../../model/profiles.js');const fs = require('fs');const path = require('path');const destr = require('destr');const uuid = require("uuid");const axios = require('axios');const { MessageEmbed } = require('discord.js');const CLAIM_COOLDOWN = 24 * 60 * 60 * 1000;const MIN_CHAPTER = 1;const MAX_CHAPTER = 2;const MIN_SEASON = 1;const MAX_SEASON = 4;const ALLOWED_TYPES = ['AthenaCharacter', 'AthenaPickaxe'];function formatTimeRemaining(ms) {    const hours = Math.floor(ms / (1000 * 60 * 60));    const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));    const seconds = Math.floor((ms % (1000 * 60)) / 1000);    if (hours > 0) {        return `${hours}h ${minutes}m ${seconds}s`;    } else if (minutes > 0) {        return `${minutes}m ${seconds}s`;    } else {        return `${seconds}s`;    }}let cosmeticsCache = null;let cacheTimestamp = null;const CACHE_DURATION = 60 * 60 * 1000;async function fetchCosmeticsFromAPI() {    try {        const response = await axios.get('https://fortnite-api.com/v2/cosmetics/br');        return response.data?.data || [];    } catch (error) {        console.error('Error fetching cosmetics:', error);        return [];    }}function filterCosmeticsBySeason(cosmetics) {    return cosmetics.filter(cosmetic => {        const introduction = cosmetic.introduction;        if (!introduction || !introduction.chapter || !introduction.season) {            return false;        }        const chapter = parseInt(introduction.chapter);        const season = introduction.season.toString();        if (chapter < MIN_CHAPTER || chapter > MAX_CHAPTER) {            return false;        }        if (chapter === 1) {            const seasonNum = parseInt(season);            if (isNaN(seasonNum) || seasonNum < MIN_SEASON || seasonNum > 10) {                return false;            }        }        if (chapter === 2) {            const seasonNum = parseInt(season);            if (isNaN(seasonNum) || seasonNum < 1 || seasonNum > MAX_SEASON) {                return false;            }        }        const type = cosmetic.type?.value?.toLowerCase();        if (!type || (type !== 'outfit' && type !== 'pickaxe')) {            return false;        }        return true;    });}function getRandomCosmetic(cosmetics) {    if (cosmetics.length === 0) return null;    const randomIndex = Math.floor(Math.random() * cosmetics.length);    return cosmetics[randomIndex];}async function getCosmeticFromAllAthena(cosmeticId) {    try {        const file = fs.readFileSync(path.join(__dirname, "../../../Config/DefaultProfiles/allathena.json"));        const jsonFile = destr(file.toString());        const items = jsonFile.items;        for (const key of Object.keys(items)) {            const [type, id] = key.split(":");            if (id === cosmeticId) {                return { key, cosmetic: items[key] };            }        }        return null;    } catch (error) {        console.error('Error reading allathena.json:', error);        return null;    }}module.exports = {    commandInfo: {        name: "claimcosmetics",        description: "Claim a random cosmetic skin or pickaxe from S1 to C2S4. 24h cooldown."    },    execute: async (interaction) => {        await interaction.deferReply({ ephemeral: true });        try {            const user = await Users.findOne({ discordId: interaction.user.id });            if (!user) {                return interaction.editReply({ content: "You do not have a registered account!", ephemeral: true });            }            const now = new Date();            const lastClaim = user.lastCosmeticsClaim ? new Date(user.lastCosmeticsClaim) : null;            if (lastClaim) {                const timeSinceLastClaim = now.getTime() - lastClaim.getTime();                const timeRemaining = CLAIM_COOLDOWN - timeSinceLastClaim;                if (timeRemaining > 0) {                    const embed = new MessageEmbed()                        .setColor("RED")                        .setTitle("‚è∞ Cooldown Active")                        .setDescription(`You can claim cosmetics again in **${formatTimeRemaining(timeRemaining)}**`)                        .setFooter({                            text: "Vortyx",                            iconURL: "https://i.imgur.com/VKPcwAJ.png"                        })                        .setTimestamp();                    return interaction.editReply({ embeds: [embed], ephemeral: true });                }            }            const profile = await Profiles.findOne({ accountId: user.accountId });            if (!profile) {                return interaction.editReply({ content: "Your profile could not be found.", ephemeral: true });            }            let allCosmetics = [];            const cacheNow = Date.now();            if (cosmeticsCache && cacheTimestamp && (cacheNow - cacheTimestamp) < CACHE_DURATION) {                allCosmetics = cosmeticsCache;            } else {                await interaction.editReply({ content: "Fetching cosmetics from API...", ephemeral: true });                allCosmetics = await fetchCosmeticsFromAPI();                cosmeticsCache = allCosmetics;                cacheTimestamp = cacheNow;            }            const filteredCosmetics = filterCosmeticsBySeason(allCosmetics);            if (filteredCosmetics.length === 0) {                console.error(`No cosmetics found. Total fetched: ${allCosmetics.length}, Filtered: ${filteredCosmetics.length}`);                return interaction.editReply({                     content: "No cosmetics found in the specified season range. Please try again later.",                     ephemeral: true                 });            }            let selectedCosmetic = null;            let cosmeticData = null;            let attempts = 0;            const maxAttempts = 50;            while (attempts < maxAttempts && !cosmeticData) {                selectedCosmetic = getRandomCosmetic(filteredCosmetics);                if (!selectedCosmetic) break;                cosmeticData = await getCosmeticFromAllAthena(selectedCosmetic.id);                if (cosmeticData) {                    if (profile.profiles.athena.items[cosmeticData.key]) {                        cosmeticData = null;                        attempts++;                        continue;                    }                    break;                }                attempts++;            }            if (!cosmeticData || !selectedCosmetic) {                return interaction.editReply({                     content: "Could not find an available cosmetic. You may already have all available cosmetics, or there was an error processing your request.",                     ephemeral: true                 });            }            const { key: foundcosmeticname, cosmetic } = cosmeticData;            const cosmeticimage = selectedCosmetic.images?.icon || selectedCosmetic.images?.smallIcon || null;            const cosmeticName = selectedCosmetic.name || foundcosmeticname;            const purchaseId = uuid.v4();            const lootList = [{                "itemType": cosmetic.templateId,                "itemGuid": cosmetic.templateId,                "quantity": 1            }];            const common_core = profile.profiles["common_core"];            const athena = profile.profiles["athena"];            common_core.items[purchaseId] = {                "templateId": `GiftBox:GB_MakeGood`,                "attributes": {                    "fromAccountId": `[Random Cosmetic Claim]`,                    "lootList": lootList,                    "params": {                        "userMessage": `Enjoy your random cosmetic from Season 1 to Chapter 2 Season 4!`                    },                    "giftedOn": new Date().toISOString()                },                "quantity": 1            };            athena.items[foundcosmeticname] = cosmetic;            let ApplyProfileChanges = [                {                    "changeType": "itemAdded",                    "itemId": foundcosmeticname,                    "templateId": cosmetic.templateId                },                {                    "changeType": "itemAdded",                    "itemId": purchaseId,                    "templateId": "GiftBox:GB_MakeGood"                }            ];            common_core.rvn++;            common_core.commandRevision++;            common_core.updated = new Date().toISOString();            athena.rvn++;            athena.commandRevision++;            athena.updated = new Date().toISOString();            await Profiles.updateOne(                { accountId: user.accountId },                {                     $set: {                         'profiles.common_core': common_core,                         'profiles.athena': athena                     }                 }            );            await Users.updateOne(                { accountId: user.accountId },                { $set: { lastCosmeticsClaim: now } }            );            const embed = new MessageEmbed()                .setTitle(" Random Cosmetic Claimed!")                .setDescription(`You successfully claimed **${cosmeticName}**!\n\nThis cosmetic is from **${selectedCosmetic.introduction?.chapter ? 'Chapter ' + selectedCosmetic.introduction.chapter : ''} ${selectedCosmetic.introduction?.season ? 'Season ' + selectedCosmetic.introduction.season : ''}** and has been added to your account as a giftbox.\n\nYou can claim again in **24 hours**!`)                .setColor("GREEN")                .setFooter({                    text: "Vortyx",                    iconURL: "https://i.imgur.com/VKPcwAJ.png"                })                .setTimestamp();            if (cosmeticimage) {                embed.setThumbnail(cosmeticimage);            }            await interaction.editReply({ embeds: [embed], ephemeral: true });        } catch (err) {            console.error('Error in claimcosmetics command:', err);            await interaction.editReply({ content: "An unexpected error occurred. Please try again later.", ephemeral: true });        }    }};